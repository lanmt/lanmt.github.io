[{"content":"Foreword： 高中的时候真的不会学习，也从来没有感到过学习的乐趣。大学有大部分的时间可以自己安排，自己摸爬滚打了三年，总是有点收获的。首先是自己的状态，生理和心理。其次是“温故而知新”，“温故”真的很重要，另外再加上自己不断的学习，在“温故”的就会遇到很多恍然大悟的瞬间。最后是眼高手低，就像背单词，背写真的很重要，要完全脱离书本，才能知道自己究竟学到了多少。\n总结\r前两章记得一些东西\rfork子进程和父进程直观上完全分离，修改子进程的内容，完全不影响父进程的内容 exec会替换调用它的进程的内存，但是会保留它的文件描述符 fork复制了文件描述符，但每一个文件当前的偏移仍然是在父子进程之间共享的（这个不用考虑exec，因为exec打开一个进程后不返回，原来的进程不会执行任何操作了） 比如下面这个代码 ↓ #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;unistd.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/stat.h\u0026gt; #include\u0026lt;fcntl.h\u0026gt; int fd=-1; int main(){ if(fd==-1) fd = open(\u0026#34;1.txt\u0026#34;,O_RDONLY); if(fork()==0) { char buf[20]=\u0026#34;********child\u0026#34;; read(fd,buf,2); printf(\u0026#34;%s\\n\u0026#34;,buf); read(fd,buf,2); printf(\u0026#34;%s\\n\u0026#34;,buf); } else{ char buf[20]=\u0026#34;********parnet\u0026#34;; read(fd,buf,2); printf(\u0026#34;%s\\n\u0026#34;,buf); read(fd,buf,2); printf(\u0026#34;%s\\n\u0026#34;,buf); } return 0; } 文件描述符是一个强大的抽象，一个进程向描述符1写出，它有可能是一个文件、一个设备、或是一个管道 稍微记一下pipe。 int pipe(int fd[2]); 往fd[1]写入的数据可以从fd[0]读出 如果 wc 指向了一个管道的写端口，那么 wc 就永远看不到 eof 了。\n如果wc执行了一个绑定了写端口的管道，那么wc就永远看不到eof了。 echo hello world \u0026gt; /tmp/xyz; wc \u0026lt; /tmp/xyz 但管道和临时文件起码有三个关键的不同点。首先，管道会进行自我清扫，如果是 shell 重定向的话，我们必须要在任务完成后删除 /tmp/xyz。第二，管道可以传输任意长度的数据。第三，管道允许同步：两个进程可以使用一对管道来进行二者之间的信息传递，每一个读操作都阻塞调用进程，直到另一个进程用 write 完成数据的发送。 父进程中创建的pipe的读写端口和子进程的读写端口是独立的，不想让read一直阻塞，就要把父进程和子进程的读写端口都close了。（同第六条） RISC-V cpu有三个执行指令有三个模式：user mode、supervisor mode、machine mode。xv6是monolithc kernel，操作系统所有的代码都以supervisor mode执行指令，unix 都是这样？ 另外还有microkernel的操作系统，它尽可能让指令以user mode执行指令。supervisor mode执行的指令出问题经常会导致内核崩溃，整个机器就g了。 一个进程有一个执行代码用的执行线程，一个进程的内存空间分为两部分，user区和kernel区，kernel区有trampoline和trapframe，trampoline是进出kernel用的，trapframe是保存/恢复进程状态用的。 恢复一个线程时，这个线程的大部分状态都保存在线程的栈上。 一个进程有两个栈，user stack 和 kernel stack。执行user指令的时候，只用到user stack，kernel stack是空的。进程用到系统调用或者中断的时候，kernel（内核）的代码，将执行在这个进程的kernel stack上，user stack还是原来的数据，但是用不到了。 RIST-V上的进程可以使用ecall指令，提高程序对硬件的权限，进入到kernel定义的入口。使用sret指令在回到用户空间。 第一个用户进程怎么运行的：\n①. 一个保存在ROM的引导加载程序加载到物理内存。（好像是在哪个文件里，静态的定义在一个数组。）\n②. 初始化一个栈，将栈顶放到sp寄存器，跳转到start。\n③. 在machine mode 完成一些初始的配置工作。在mstatus寄存器中设置为supervisor mode，然后将main函数的地址写入到mepc寄存器中，通过对satp寄存器清0禁用页表。现在中断和异常都由监管者模式下处理，并设置好计时器，可以产生时钟中断。\n④. 通过mret将start函数返回到main函数，现在正式处于监管者模式运行。\n⑤. 调用userinit函数创建第一个进程，exec（/init），init随后完成一些设置，包括创建一个控制台、文件描述符012、新建一个子进程运行shell。\\ 在用户代码执行exec，请求系统调用函数exec，用户参数放在a0和a1，系统调用号放在a7，然后执行ecall。然后执行syscall函数，通过函数指针执行相应的系统调用。然后就执行系统调用sys_exec，完成一些检查和相关参数复制，就执行kernel/exec.c中的内容。最后系统调用结束会有一个返回值，放在trapframe的a0中。 用户传来的虚拟地址（参数），通过一系列函数（在中间有个walkaddr函数检查是否在用户的页表中）转换成内核的虚拟地址，xv6核的虚拟地址和物理地址是直接映射的，就可以去读取用户传来的参数了。（看不懂自己写的东西了，，为什么用户传来的虚拟地址要转换成内核的虚拟地址？？？） TLB和普通的缓存工作的顺序：cpu首先处理的是virtual address，会先转换成物理地址（这里会使用TLB加速），然后有物理内存之后，再去访问普通的缓存，看这个地址是否在cache中，否则会继续向主存访问。 对页表的理解\r页表存在于物理内存中，地址放在satp寄存器里，当需要从一个虚拟地址转换乘物理地址的时候，就需要把这个虚拟地址中间的27位拆开一层一层寻址，图中PPN和Flags就是一个pte(page table entry)，其中flag包括一些标志位 PTE_V指示PTE是否存在/有效。如果不存在，尝试引用该页时就会引发一个缺页错误异常。 PTE_R指示这一页物理帧是否能被读。 PTE_W指示这一页物理帧是否能被写。 PTE_X指示这一页物理帧是否能被CPU看待并转换成指令来执行。 PTE_U指示这一页物理帧在用户模式下是否能访问。如果没有置位，则该一页物理帧只能在监管者模式下被访问。 注意一点，指令永远只使用虚拟地址，虚拟地址转换成物理地址是MMU分页硬件负责的，但是系统刚启动时会通过代码模拟MMU创建内核页表\n用户虚拟地址空间和内核虚拟地址空间\r内核虚拟地址空间\r从KERNBASE向上才对应RAM的存储空间，访问下方的物理地址，实际上是直接访问相关的I/O设备的控制寄存器 未使用页表的时候，访问RAM时，内核的虚拟地址会采用直接映射的方式进行转换，这种直接映射，也会在初始化内核页表的过程(kernel/vm.c)中保留下来。虚拟地址的顶端有个trampline页，再往下是每个用户的内核栈，每个内核栈上面有一个guard page，PTE_V标记为无效，防止越界破坏内核空间，guard page并没有实际的物理帧对应。\n用户虚拟地址空间\r用户的虚拟地址空间是连续的，这个体现在释放内存空间的时候，只需要从0地址开始，释放p-\u0026gt;sz大小的内存就行了。与内核虚拟地址空间不同，用户stack是从上向下申请内存，guard page在stack的下面，而且用实际的物理帧对应。xv6为了简便，data和text放在了同一个页，实际的操作系统都是放在不同的页内。\nELF二进制文件\r大改这样组成：一个ELF Header，后面紧跟一系列的Program Section Headers。每个Program Section Headers都对应一段需要加载到内存中的程序，xv6中只有一个，其他的操作系统可能有很多个。\n// File header struct elfhdr { uint magic; // must equal ELF_MAGIC uchar elf[12]; ushort type; ushort machine; uint version; uint64 entry; uint64 phoff; uint64 shoff; uint flags; ushort ehsize; ushort phentsize; ushort phnum; ushort shentsize; ushort shnum; ushort shstrndx; }; // Program section header struct proghdr { uint32 type; uint32 flags; uint64 off; uint64 vaddr; uint64 paddr; uint64 filesz; uint64 memsz; uint64 align; }; // Format of an ELF executable file #define ELF_MAGIC 0x464C457FU // \u0026#34;\\x7FELF\u0026#34; in little endian // 这里有个魔数哎 // Values for Proghdr type #define ELF_PROG_LOAD 1 // Flag bits for Proghdr flags #define ELF_PROG_FLAG_EXEC 1 #define ELF_PROG_FLAG_WRITE 2 #define ELF_PROG_FLAG_READ 4 执行一个ELF文件的过程\r使用exec读取文件之后，首先检查文件是否为ELF文件\n// 也就是检查魔数是不是0x464C457FU if(readi(ip, 0, (uint64)\u0026amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; if(elf.magic != ELF_MAGIC) goto bad; 然后调用proc_pagetable,创建一个新页表，添加trampoline和trapframe的映射\nif((pagetable = proc_pagetable(p)) == 0) goto bad; // Create a user page table for a given process, // with no user memory, but with trampoline pages. pagetable_t proc_pagetable(struct proc *p) { pagetable_t pagetable; // An empty page table. pagetable = uvmcreate(); if(pagetable == 0) return 0; // map the trampoline code (for system call return) // at the highest user virtual address. // only the supervisor uses it, on the way // to/from user space, so not PTE_U. if(mappages(pagetable, TRAMPOLINE, PGSIZE, (uint64)trampoline, PTE_R | PTE_X) \u0026lt; 0){ uvmfree(pagetable, 0); return 0; } // map the trapframe just below TRAMPOLINE, for trampoline.S. if(mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-\u0026gt;trapframe), PTE_R | PTE_W) \u0026lt; 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } return pagetable; } // create an empty user page table. // returns 0 if out of memory. pagetable_t uvmcreate() { pagetable_t pagetable; pagetable = (pagetable_t) kalloc(); if(pagetable == 0) return 0; memset(pagetable, 0, PGSIZE); return pagetable; } 然后，exec对于每个程序段，先是调用uvmalloc分配足够的物理帧，更新了用户页表。然后调用loadseg加载程序段到这些物理帧中。loadseg将虚拟地址传给walkaddr，walkaddr又通过walk查找相关PTE，将va转换为pa，最后walkaddr成功返回uvmalloc分配的物理帧的物理地址，loadseg再调用readi，真正地将程序段加载到物理内存中。\n// Load program into memory for(i=0, off=elf.phoff; i\u0026lt;elf.phnum; i++, off+=sizeof(ph)){ if(readi(ip, 0, (uint64)\u0026amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; if(ph.type != ELF_PROG_LOAD) continue; if(ph.memsz \u0026lt; ph.filesz) goto bad; if(ph.vaddr + ph.memsz \u0026lt; ph.vaddr) goto bad; uint64 sz1; // 通过uvmalloc为每个ELF段分配内存 // 刚分配的内存是全的0 if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad; sz = sz1; if(ph.vaddr % PGSIZE != 0) goto bad; // 然后通过loadseg把段的内容载入物理内存中 // loadseg通过walkaddr找到写入ELF段的内存的物理地址；通过readi来将段的内容从文件中读出 if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) \u0026lt; 0) goto bad; } // Load a program segment into pagetable at virtual address va. // va must be page-aligned // and the pages from va to va+sz must already be mapped. // Returns 0 on success, -1 on failure. static int loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz) { uint i, n; uint64 pa; if((va % PGSIZE) != 0) panic(\u0026#34;loadseg: va must be page aligned\u0026#34;); for(i = 0; i \u0026lt; sz; i += PGSIZE){ pa = walkaddr(pagetable, va + i); if(pa == 0) panic(\u0026#34;loadseg: address should exist\u0026#34;); if(sz - i \u0026lt; PGSIZE) n = sz - i; else n = PGSIZE; if(readi(ip, 0, (uint64)pa, offset+i, n) != n) return -1; } return 0; } // Look up a virtual address, return the physical address, // or 0 if not mapped. // Can only be used to look up user pages. uint64 walkaddr(pagetable_t pagetable, uint64 va) { pte_t *pte; uint64 pa; if(va \u0026gt;= MAXVA) return 0; pte = walk(pagetable, va, 0); if(pte == 0) return 0; if((*pte \u0026amp; PTE_V) == 0) return 0; if((*pte \u0026amp; PTE_U) == 0) return 0; pa = PTE2PA(*pte); return pa; } 现在TRAMPOLINE、TRAPFRAME、各程序段都装载完成了，（这个程序段是在外存读进来的吗？不懂。。。），接下来就是分配并初始化用户栈,对比用户虚拟地址空间。\n// 到这里，用户空间的text和data都已经加载完毕了 // Allocate two pages at the next page boundary. // 紧接着data的位置向上继续分配两个页，第一页用作guard page，第二页用作user stack // ustack中的前三项就是伪造的返回PC值，argc和argv指针 sz = PGROUNDUP(sz); uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) goto bad; sz = sz1; // uvmclear将PTE_U设为无效，因此这一页用作保护页 uvmclear(pagetable, sz-2*PGSIZE); sp = sz; stackbase = sp - PGSIZE; // Push argument strings, prepare rest of stack in ustack. for(argc = 0; argv[argc]; argc++) { if(argc \u0026gt;= MAXARG) goto bad; sp -= strlen(argv[argc]) + 1; sp -= sp % 16; // riscv sp must be 16-byte aligned if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) \u0026lt; 0) // 保护页还让exec能够处理那些过于庞大的参数；当参数过于庞大时， // exec 用于将参数拷贝到栈上的函数copyout会发现目标页无法访问，并且返回-1 goto bad; ustack[argc] = sp; } ustack[argc] = 0; // push the array of argv[] pointers. sp -= (argc+1) * sizeof(uint64); sp -= sp % 16; if(sp \u0026lt; stackbase) goto bad; if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) \u0026lt; 0) goto bad; // arguments to user main(argc, argv) // argc is returned via the system call return // value, which goes in a0. // 现在的sp指向argv[]数组，argc通过a0寄存器i 返回 p-\u0026gt;trapframe-\u0026gt;a1 = sp; // Save program name for debugging. for(last=s=path; *s; s++) if(*s == \u0026#39;/\u0026#39;) last = s+1; safestrcpy(p-\u0026gt;name, last, sizeof(p-\u0026gt;name)); // Commit to the user image. oldpagetable = p-\u0026gt;pagetable; p-\u0026gt;pagetable = pagetable; p-\u0026gt;sz = sz; // 注意，在用户进程被创建的时候，这里就将返回到main的pc值放到寄存器epc里面 p-\u0026gt;trapframe-\u0026gt;epc = elf.entry; // initial program counter = main p-\u0026gt;trapframe-\u0026gt;sp = sp; // initial stack pointer proc_freepagetable(oldpagetable, oldsz); // the C calling convention on RISC-V places return values in a0 return argc; // this ends up in a0, the first argument to main(argc, argv) 实验总结\r这节实验有点难啊，可以说最后以失败告终，一直找不到问题出在哪里，但是看了别人写的实验记录，还是有点收获和感悟的。\nPrint a page table\r这个比较简单，清楚页表的结构，会用指针就很容易实现。这个实验我写了两次，刚开始没有理解，一直纠结pte前面的pnn里是不是也是虚拟地址。\nvoid _vmprint(pagetable_t pagetable, int level) { for (int i = 0; i \u0026lt; 512; i++) { pte_t pte = pagetable[i]; if (pte \u0026amp; PTE_V) { uint64 pa = PTE2PA(pte); for (int j = 0; j \u0026lt; level; j++) { if (j) printf(\u0026#34; \u0026#34;); printf(\u0026#34;..\u0026#34;); } printf(\u0026#34;%d: pte %p pa %p\\n\u0026#34;, i, pte, pa); if ((pte \u0026amp; (PTE_R | PTE_W | PTE_X)) == 0) { _vmprint((pagetable_t)pa, level+1); } } } } void vmprint(pagetable_t pagetable) { printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); _vmprint(pagetable, 1); } A kernel page table per process\r实验大意就是用户使用虚拟地址要转换成物理地址，但是内核页表因为是直接映射的，所以就不需要转换，这个任务就是给每个进程都组织一个内核空间（其实就是维护一个页表）\n首先仿照（kernel/vm.c）kvminit函数创建一个页表，然后分配各个页\nvoid ukvmmap(pagetable_t kpagetable, uint64 va, uint64 pa, uint64 sz, int perm) { if(mappages(kpagetable, va, sz, pa, perm) != 0) panic(\u0026#34;uvmmap\u0026#34;); } pagetable_t ukvminit() { pagetable_t kpagetable = (pagetable_t) kalloc(); memset(kpagetable, 0, PGSIZE); ukvmmap(kpagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W); ukvmmap(kpagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); ukvmmap(kpagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W); ukvmmap(kpagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W); ukvmmap(kpagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); ukvmmap(kpagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); ukvmmap(kpagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); return kpagetable; } 在kernel/proc.c中的allocproc函数中添加调用函数的代码\n// An empty user kernel page table. p-\u0026gt;kpagetable = ukvminit(); if(p-\u0026gt;kpagetable == 0) { freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } 然后把每个进程的内核栈放在他自己的内核空间中\nchar *pa = kalloc(); if(pa == 0) panic(\u0026#34;kalloc\u0026#34;); // KSTACK会直接分配两个页，因为每个进程的内核空间只有他自己的 // 内核栈，所以用一个没有使用的地址就可以 uint64 va = KSTACK((int)TRAMPOLINE - 2*PGSIZE); ukvmmap(p-\u0026gt;kpagetable, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); p-\u0026gt;kstack = va; 进程调度时，切换satp寄存器，使用kpagetable\n// change satp w_satp(MAKE_SATP(p-\u0026gt;kpagetable)); sfence_vma(); // 没有runnable的进程就使用内核的页表 kvminithart(); 释放进程的时候，先释放页表的内核栈，因为内核栈的地址是一个虚拟地址，不是直接映射的，用户的内核页表没有记录，所以要先释放。\n// delete kstack if(p-\u0026gt;kstack) { pte_t* pte = walk(p-\u0026gt;kpagetable, p-\u0026gt;kstack, 0); if(pte == 0) panic(\u0026#34;freeproc: walk\u0026#34;); kfree((void*)PTE2PA(*pte)); } p-\u0026gt;kstack = 0; 然后释放用户的内核页表\nvoid proc_freewalk(pagetable_t pagetable) { for (int i = 0; i \u0026lt; 512; i++) { pte_t pte = pagetable[i]; if (pte \u0026amp; PTE_V) { pagetable[i] = 0; if ((pte \u0026amp; (PTE_R | PTE_W | PTE_X)) == 0) { uint64 child = PTE2PA(pte); proc_freewalk((pagetable_t)child); } } } kfree((void*)pagetable); } Simplify copyin/copyinstr\r内核的copyin函数读取用户指针指向的内存。它先将它们翻译为物理地址（内核可以直接用）。通过代码walk进程页表实现翻译。 在此实验中，你的工作是给每个进程的内核页表添加用户映射，使得copyin可以直接使用用户指针。\n因为用户虚拟内存空间是从0开始分配的，而用户的内核地址空间（kpagetable组织的）0x0C000000以下都没用，所以就可以把用户页表的所有pte复制到kpagetable，但是要注意判断是否超过了0x0C000000。\n这个并不是很难，只是下面这个复制条目的不好写\nvoid u2kvmcopy(pagetable_t upagetable, pagetable_t kpagetable, uint64 oldsz, uint64 newsz) { oldsz = PGROUNDUP(oldsz); for (uint64 i = oldsz; i \u0026lt; newsz; i += PGSIZE) { pte_t* pte_from = walk(upagetable, i, 0); pte_t* pte_to = walk(kpagetable, i, 1); if(pte_from == 0) panic(\u0026#34;u2kvmcopy: src pte do not exist\u0026#34;); if(pte_to == 0) panic(\u0026#34;u2kvmcopy: dest pte walk fail\u0026#34;); uint64 pa = PTE2PA(*pte_from); uint flag = (PTE_FLAGS(*pte_from)) \u0026amp; (~PTE_U); *pte_to = PA2PTE(pa) | flag; } } fork执行的时候子进程会复制父进程的内存映像\n//这里子进程已经生成了kpagetable，但是用户pagetable的低地址还没复制到kpagetable的高地址 // Allocate process. if((np = allocproc()) == 0){ return -1; } // Copy user memory from parent to child. if(uvmcopy(p-\u0026gt;pagetable, np-\u0026gt;pagetable, p-\u0026gt;sz) \u0026lt; 0){ panic(\u0026#34;fork:uvmcopy\\n\u0026#34;); freeproc(np); release(\u0026amp;np-\u0026gt;lock); return -1; } ","date":"2024-06-20T00:00:00Z","permalink":"http://localhost:1313/post/6.s081%E5%89%8D%E4%B8%89%E7%AB%A0/","title":"xv6-book 前三章内容总结"},{"content":"对向量的认识\r对于学物理的同学来说，向量就是一个箭头。对于学计算机的同学来说，向量就是一组有序的数，比如stl的vector。我比较害怕数学家，就不讨论学数学的同学了。\n在线性代数中的向量\r向量有两个基本的运算贯穿线性代数始终，分别是向量+向量和标量×向量 ，另外在线性代数里，几乎所有的向量都可以默认是从原点（0,0）起始的。\n二维空间中向量的运算\r向量+向量符合平行四边形法则，也就是把其中一个向量的起点移动到另一个向量的终点。如下图：\n标量×向量就是对向量的伸缩\n线性相关性\r考虑在二维空间中，如果一个向量可以由另外几个向量通过上面两个运算得到，则称他们是线性相关的。否则他们是线性无关的\n张成的空间\r给一个向量集，如$\\vec{a},\\vec{b}$,两个标量$x,y$可取任意值，$x\\vec{a}+y\\vec{b}$能表达的所有向量终点的集合就是这个向量集张成的空间\n基\r基的严格定义：向量空间的一组基是张成该空间的一个线性无关向量集\n特殊的，在二维空间中，两个不共线的向量就是一组基，他们能表示在这个二维平面中任意一个向量。\n线性变换\r线性变换可以看成对基向量的变换。\n线性变换可以看成对空间的挤压伸展，保持网格线平行且等距相等。\n比如逆时针旋九十度，我们可以追踪i帽和j帽的变化，用矩阵描述这个线性变换。（同维度的变换肯定是方阵）\n两个条件：一是原来的直线，在变换之后还是直线。二是原点必须固定。\n严格定义：\nAdditivity:$L(\\vec{v}+\\vec{w})=L((\\vec{v})+L({\\vec{w}}))$\nScaling:$L(c\\vec{v})=cL(\\vec{v})$\n矩阵乘法\r两次线性变换叠加，换成矩阵乘法，如下图所示。（先旋转再剪切，也就是旋转后的基向量，再根据剪切矩阵转换。） 显然变换的顺序不同，乘法的结果也不同。\n从线性变换的角度来看矩阵乘法结合律，(AB)C和A(BC)都是按CBA的顺序变换的，所以这两个式子相等。\n行列式\r一个2x2的矩阵的行列式在二维空间中可以看成单位正方形在变换后面积的变化。\n同理3x3的矩阵的行列式在三维空间中可以看成单位立方体在变换后面积的变化。如果面积变成了0，则这个矩阵的列肯定是线性相关的。\n对于两个变换M，N，det(MN)=det(M)*det(N)，在二维空间中直观上可以想象单位正方形面积的变化。\n逆矩阵\r$A\\vec{x}=\\vec{a}$。几何意义是找到一个向量 $\\vec{x}$，经过A变换之后变成 $\\vec{a}$。定义从 $\\vec{a}$ 到 $\\vec{x}$ 的变换为A的逆，记为 $A^{-1}$，有$AA^{-1}\\vec{x}=I\\vec{x}=A^{-1}\\vec{a}$。\n列空间、秩、零空间\r对于一个nxn的方阵，每一列都对应一个基向量，这组基张成的空间就是列空间。秩等于列空间的维度。等于n的话就是满秩，也就是这些列向量线性无关。\n如果不是满秩，假设在二维空间中，变换之后空间变成了一条线，则在某一条直线上的向量，经过变换之后被压缩到了原点，这条线称为零空间。在三维空间中，如果变换之后空间变成了一条线，则零空间是一个平面。\n点乘\r在二维平面中，点乘可以看成降维的线性变换，平面变成一个数轴（这个数轴可以和其中任何一个向量共线），变换后在这个数轴上的值就是点乘的结果。 下面这个图中，u是这个数轴的单位向量。 这一集有点困难。看了不下五遍。\n叉乘\r大小是行列式的值，方向垂直于两个向量（使用右手判断方向）。\n后面在线性变换的角度，通过对偶性引入点乘，解释了这个式子，不过我只看了一遍，不是很懂。\n基变换\r选用不同的基向量，描述同一个向量的的结果不同。\n在二维空间中，我们比较容易接受的一组基向量是(1,0)和(0,1)，对于不同的基向量，我们可以理解为从原来的空间通过线性变换转换，矩阵记为A。对于我们熟知的线性变换，比如逆时针旋转九十度，矩阵记为M。\n一个向量 $\\vec{v}$，转换到A变换的空间逆时针旋转九十度为 $A^{-1}MA\\vec{v}$。\n特征值、特征向量\r一些向量在线性变换后，只改变大小，对于这种向量满足 $M\\vec{v}=λ\\vec{v}$，$λ$可以写成$λI$，整理一下$(M-λI)v=\\vec{0}$，也就是让左边这个矩阵的行列式等于0，计算出特征值，代入原来的式子就能得到特征向量所在的空间了（二维空间中一般是直线方程）。\n利用只改变大小的性质，可以通过基变换，把基向量转换成能张成原来空间的若干个特征向量（这组基叫特征基），可以简化多次利用这种变换的计算。\n如下图，先转换基向量，再进行线性变换，在转换到原来的坐标系，只是伸缩了大小。\n抽象向量空间\r满足八大定理，随意定义一些东西，就可以使用向量的所有性质和计算方法。\n克莱姆法则\r如下图，黄色区域的面积是x。\n该黄色区域的变化相当于把基向量为红色和粉色的线性变换。这个面积相当于单位正方形。\n","date":"2024-06-19T00:00:00Z","permalink":"http://localhost:1313/post/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/","title":"线性代数的本质"},{"content":"123\n","date":"2024-06-12T16:47:24+08:00","permalink":"http://localhost:1313/post/test/","title":"Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings\rThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1\rH2\rH3\rH4\rH5\rH6\rParagraph\rXerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes\rThe blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution\rTiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution\rDon\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables\rTables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables\rItalics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks\rCode block with backticks\r\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces\r\u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rDiff code block\r[dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block\r\u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types\rOrdered List\rFirst item Second item Third item Unordered List\rList item Another item And another item Nested list\rFruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark\rGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-09-07T00:00:00Z","permalink":"http://localhost:1313/post/markdown-syntax/","title":"Markdown Syntax Guide"}]